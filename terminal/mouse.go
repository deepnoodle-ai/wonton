package terminal

import (
	"fmt"
	"time"
)

// MouseEvent represents a mouse interaction event from the terminal.
//
// Mouse events are generated when mouse tracking is enabled via
// Terminal.EnableMouseTracking() or Terminal.EnableMouseButtons().
//
// The event includes:
//   - Position (X, Y) in terminal character cells (0-based)
//   - Button that was pressed/released
//   - Type of event (press, release, click, drag, move, scroll)
//   - Keyboard modifiers held during the event (Shift, Alt, Ctrl)
//   - For wheel events: delta in X or Y direction
//   - For click events: click count (1=single, 2=double, 3=triple)
//
// Example handling different mouse events:
//
//	switch event.Type {
//	case terminal.MouseClick:
//	    if event.Button == terminal.MouseButtonLeft {
//	        fmt.Printf("Left click at %d,%d\n", event.X, event.Y)
//	    }
//	case terminal.MouseScroll:
//	    if event.Button == terminal.MouseButtonWheelUp {
//	        fmt.Println("Scrolled up")
//	    }
//	case terminal.MouseDrag:
//	    fmt.Printf("Dragging to %d,%d\n", event.X, event.Y)
//	}
type MouseEvent struct {
	X, Y       int            // Position in terminal cells (0-based)
	Button     MouseButton    // Which button was involved
	Type       MouseEventType // Type of mouse event
	Modifiers  MouseModifiers // Keyboard modifiers held during event
	DeltaX     int            // Horizontal scroll delta (for wheel events, negative=left, positive=right)
	DeltaY     int            // Vertical scroll delta (for wheel events, negative=up, positive=down)
	Time       time.Time      // When the event occurred
	ClickCount int            // Click count: 1=single, 2=double, 3=triple
}

// Timestamp implements the Event interface
func (e MouseEvent) Timestamp() time.Time {
	return e.Time
}

// MouseButton represents which mouse button was involved in the event.
type MouseButton int

const (
	MouseButtonLeft   MouseButton = iota // Left mouse button
	MouseButtonMiddle                    // Middle mouse button (often scroll wheel click)
	MouseButtonRight                     // Right mouse button
	MouseButtonNone                      // No button (for move/release events)

	// Wheel buttons represent scroll wheel events
	MouseButtonWheelUp    // Mouse wheel scrolled up
	MouseButtonWheelDown  // Mouse wheel scrolled down
	MouseButtonWheelLeft  // Mouse wheel scrolled left (horizontal scroll)
	MouseButtonWheelRight // Mouse wheel scrolled right (horizontal scroll)
)

// MouseEventType represents the type of mouse event.
// Different event types are generated based on the mouse action and state.
type MouseEventType int

const (
	MousePress  MouseEventType = iota // Button pressed down
	MouseRelease                      // Button released
	MouseClick                        // Single click (press + release without significant movement)
	MouseDoubleClick                  // Double click (two clicks in quick succession)
	MouseTripleClick                  // Triple click (three clicks in quick succession)
	MouseDrag                         // Mouse moved while button held (after drag threshold exceeded)
	MouseDragStart                    // Drag operation started (threshold exceeded)
	MouseDragEnd                      // Drag operation ended (button released after drag)
	MouseDragCancel                   // Drag operation cancelled (e.g., by pressing Escape)
	MouseMove                         // Mouse moved without button pressed (requires EnableMouseTracking)
	MouseEnter                        // Mouse entered a region (generated by MouseHandler)
	MouseLeave                        // Mouse left a region (generated by MouseHandler)
	MouseScroll                       // Mouse wheel scrolled
)

// MouseModifiers represents keyboard modifiers held during mouse event
type MouseModifiers int

const (
	ModShift MouseModifiers = 1 << iota
	ModAlt
	ModCtrl
	ModMeta
)

// ParseMouseEvent parses a mouse event from terminal input.
// It supports both SGR format (<button>;x;y[Mm]) and legacy format (3 bytes).
func ParseMouseEvent(seq []byte) (*MouseEvent, error) {
	// SGR format: \033[<button>;x;yM (press) or m (release)
	// Example: \033[<0;10;5M for left click at (10,5)

	if len(seq) < 3 {
		return nil, fmt.Errorf("invalid mouse sequence: too short")
	}

	// Parse the sequence
	var button, x, y int
	var action byte

	// Look for SGR format
	if seq[0] == '<' {
		// Parse SGR format: <button>;x;y[Mm]
		end := 1
		for end < len(seq) && seq[end] != 'M' && seq[end] != 'm' {
			end++
		}
		if end >= len(seq) {
			return nil, fmt.Errorf("incomplete mouse sequence")
		}

		action = seq[end]
		coords := string(seq[1:end])

		if _, err := fmt.Sscanf(coords, "%d;%d;%d", &button, &x, &y); err != nil {
			return nil, err
		}
	} else {
		// Legacy format - limited to coordinates < 223
		if len(seq) != 3 {
			return nil, fmt.Errorf("invalid legacy mouse sequence")
		}
		button = int(seq[0]) - 32
		x = int(seq[1]) - 32
		y = int(seq[2]) - 32
		action = 'M' // Legacy is always press
	}

	// Convert to 0-based coordinates
	x--
	y--

	event := &MouseEvent{
		X:    x,
		Y:    y,
		Time: time.Now(),
	}

	// Parse modifiers (bits 2-4 of button byte)
	if button&4 != 0 {
		event.Modifiers |= ModShift
	}
	if button&8 != 0 {
		event.Modifiers |= ModAlt
	}
	if button&16 != 0 {
		event.Modifiers |= ModCtrl
	}

	// Determine button and type
	if action == 'm' {
		event.Button = MouseButtonNone
		event.Type = MouseRelease
	} else {
		baseButton := button & 3

		// Check for wheel events first
		if button&64 != 0 {
			event.Type = MouseScroll
			// Bit 0 determines up/down, bit 1 determines vertical/horizontal
			if button&2 != 0 {
				// Horizontal wheel
				if button&1 != 0 {
					event.Button = MouseButtonWheelRight
					event.DeltaX = 1
				} else {
					event.Button = MouseButtonWheelLeft
					event.DeltaX = -1
				}
			} else {
				// Vertical wheel
				if button&1 != 0 {
					event.Button = MouseButtonWheelDown
					event.DeltaY = 1
				} else {
					event.Button = MouseButtonWheelUp
					event.DeltaY = -1
				}
			}
		} else if button&32 != 0 {
			// Motion flag is set
			if baseButton == 3 {
				// No button pressed - this is just mouse movement
				event.Type = MouseMove
				event.Button = MouseButtonNone
			} else {
				// Button pressed while moving - this is a drag
				event.Type = MouseDrag
				switch baseButton {
				case 0:
					event.Button = MouseButtonLeft
				case 1:
					event.Button = MouseButtonMiddle
				case 2:
					event.Button = MouseButtonRight
				}
			}
		} else {
			// Regular press event
			event.Type = MousePress
			switch baseButton {
			case 0:
				event.Button = MouseButtonLeft
			case 1:
				event.Button = MouseButtonMiddle
			case 2:
				event.Button = MouseButtonRight
			case 3:
				event.Button = MouseButtonNone
			}
		}
	}

	return event, nil
}

// CursorStyle represents a visual cursor style hint for mouse regions.
// These are semantic hints - actual terminal cursor changes must be implemented separately.
type CursorStyle int

const (
	CursorDefault    CursorStyle = iota // Default arrow cursor
	CursorPointer                       // Pointing hand (for clickable elements)
	CursorText                          // I-beam text cursor (for text input)
	CursorResizeEW                      // East-West resize cursor (horizontal)
	CursorResizeNS                      // North-South resize cursor (vertical)
	CursorResizeNESW                    // Northeast-Southwest diagonal resize
	CursorResizeNWSE                    // Northwest-Southeast diagonal resize
	CursorMove                          // Move cursor (for draggable elements)
	CursorNotAllowed                    // Not allowed cursor (for disabled elements)
)

// MouseRegion represents a rectangular clickable area on the screen.
// Regions can have event handlers attached and are managed by MouseHandler.
//
// Regions support layering via ZIndex - higher ZIndex regions receive events first.
// This allows creating overlapping interactive areas like buttons, menus, and modals.
//
// Example:
//
//	region := &terminal.MouseRegion{
//	    X: 10, Y: 5,
//	    Width: 20, Height: 3,
//	    ZIndex: 1,
//	    Label: "Submit Button",
//	    CursorStyle: terminal.CursorPointer,
//	    OnClick: func(event *terminal.MouseEvent) {
//	        fmt.Println("Button clicked!")
//	    },
//	    OnEnter: func(event *terminal.MouseEvent) {
//	        // Highlight button
//	    },
//	    OnLeave: func(event *terminal.MouseEvent) {
//	        // Remove highlight
//	    },
//	}
//	handler.AddRegion(region)
type MouseRegion struct {
	X, Y          int         // Top-left position in terminal cells
	Width, Height int         // Size in terminal cells
	ZIndex        int         // Layer order (higher = on top, receives events first)
	Label         string      // Optional label for debugging
	CursorStyle   CursorStyle // Visual cursor hint

	// Event handlers - all are optional and called when corresponding events occur
	OnPress       func(event *MouseEvent) // Button pressed in region
	OnRelease     func(event *MouseEvent) // Button released in region
	OnClick       func(event *MouseEvent) // Clicked in region (press + release without much movement)
	OnDoubleClick func(event *MouseEvent) // Double-clicked in region
	OnTripleClick func(event *MouseEvent) // Triple-clicked in region
	OnEnter       func(event *MouseEvent) // Mouse entered region
	OnLeave       func(event *MouseEvent) // Mouse left region
	OnMove        func(event *MouseEvent) // Mouse moved within region (requires EnableMouseTracking)
	OnDragStart   func(event *MouseEvent) // Drag started in region
	OnDrag        func(event *MouseEvent) // Dragging within region
	OnDragEnd     func(event *MouseEvent) // Drag ended in region
	OnScroll      func(event *MouseEvent) // Mouse wheel scrolled in region
}

// Contains checks if a point is within the region's bounds.
// Coordinates are in terminal cells (0-based).
func (r *MouseRegion) Contains(x, y int) bool {
	return x >= r.X && x < r.X+r.Width &&
		y >= r.Y && y < r.Y+r.Height
}
