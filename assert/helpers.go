package assert

import (
	"bytes"
	"fmt"
	"os"
	"reflect"
	"regexp"
	"runtime"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/deepnoodle-ai/wonton/color"
)

// colorEnabled controls whether colored output is used.
// It defaults to true if stderr is a terminal.
var colorEnabled = color.IsTerminal(os.Stderr)

// SetColorEnabled enables or disables colored output.
func SetColorEnabled(enabled bool) {
	colorEnabled = enabled
}

// ColorEnabled returns whether colored output is enabled.
func ColorEnabled() bool {
	return colorEnabled
}

// formatMessage formats the optional message and arguments.
func formatMessage(msgAndArgs ...any) string {
	if len(msgAndArgs) == 0 {
		return ""
	}
	if len(msgAndArgs) == 1 {
		if msg, ok := msgAndArgs[0].(string); ok {
			return msg
		}
		return fmt.Sprintf("%+v", msgAndArgs[0])
	}
	if msg, ok := msgAndArgs[0].(string); ok {
		return fmt.Sprintf(msg, msgAndArgs[1:]...)
	}
	return ""
}

// labeledContent represents a labeled piece of output.
type labeledContent struct {
	label   string
	content string
}

// formatLabeledOutput formats labeled content for display.
func formatLabeledOutput(content ...labeledContent) string {
	longestLabel := 0
	for _, v := range content {
		if len(v.label) > longestLabel {
			longestLabel = len(v.label)
		}
	}
	var output string
	for _, v := range content {
		label := v.label
		if colorEnabled {
			label = color.Cyan.Apply(v.label)
		}
		output += "\t" + label + ":" + strings.Repeat(" ", longestLabel-len(v.label)) + "\t" + indentMessageLines(v.content, longestLabel) + "\n"
	}
	return output
}

// indentMessageLines aligns multi-line messages.
func indentMessageLines(message string, longestLabelLen int) string {
	lines := strings.Split(message, "\n")
	if len(lines) == 1 {
		return message
	}
	indent := "\n\t" + strings.Repeat(" ", longestLabelLen+1) + "\t"
	return strings.Join(lines, indent)
}

// callerInfo returns an array of strings containing the file and line number
// of each stack frame leading to the assert call.
func callerInfo() []string {
	const maxFrames = 10
	pcs := make([]uintptr, maxFrames)

	callers := []string{}
	offset := 1

	for {
		n := runtime.Callers(offset, pcs)
		if n == 0 {
			break
		}
		frames := runtime.CallersFrames(pcs[:n])
		for {
			frame, more := frames.Next()
			file := frame.File
			line := frame.Line
			if file == "<autogenerated>" {
				break
			}
			f := runtime.FuncForPC(frame.PC)
			if f == nil {
				break
			}
			name := f.Name()
			if name == "testing.tRunner" {
				break
			}
			parts := strings.Split(file, "/")
			if len(parts) > 1 {
				dir := parts[len(parts)-2]
				if dir != "assert" && dir != "require" {
					callers = append(callers, fmt.Sprintf("%s:%d", file, line))
				}
			}
			// Drop the package
			dotPos := strings.LastIndexByte(name, '.')
			name = name[dotPos+1:]
			if isTest(name, "Test") || isTest(name, "Benchmark") || isTest(name, "Example") {
				break
			}
			if !more {
				break
			}
		}
		offset += cap(pcs)
	}
	return callers
}

// isTest tells whether name looks like a test function.
func isTest(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) {
		return true
	}
	r, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(r)
}

// objectsAreEqual determines if two objects are considered equal.
func objectsAreEqual(expected, actual any) bool {
	if expected == nil || actual == nil {
		return expected == actual
	}
	exp, ok := expected.([]byte)
	if !ok {
		return reflect.DeepEqual(expected, actual)
	}
	act, ok := actual.([]byte)
	if !ok {
		return false
	}
	if exp == nil || act == nil {
		return exp == nil && act == nil
	}
	return bytes.Equal(exp, act)
}

// validateEqualArgs checks whether provided arguments can be safely compared.
func validateEqualArgs(expected, actual any) error {
	if expected == nil && actual == nil {
		return nil
	}
	if isFunction(expected) || isFunction(actual) {
		return fmt.Errorf("cannot compare functions")
	}
	return nil
}

// isFunction returns true if the argument is a function.
func isFunction(arg any) bool {
	if arg == nil {
		return false
	}
	return reflect.TypeOf(arg).Kind() == reflect.Func
}

// isNil checks if a specified object is nil.
func isNil(object any) bool {
	if object == nil {
		return true
	}
	value := reflect.ValueOf(object)
	switch value.Kind() {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:
		return value.IsNil()
	}
	return false
}

// samePointers checks if two pointers point to the same object.
func samePointers(first, second any) (same bool, ok bool) {
	firstPtr, secondPtr := reflect.ValueOf(first), reflect.ValueOf(second)
	if firstPtr.Kind() != reflect.Ptr || secondPtr.Kind() != reflect.Ptr {
		return false, false
	}
	firstType, secondType := reflect.TypeOf(first), reflect.TypeOf(second)
	if firstType != secondType {
		return false, true
	}
	return first == second, true
}

// isEmpty checks if a specified object is considered empty.
func isEmpty(object any) bool {
	if object == nil {
		return true
	}
	objValue := reflect.ValueOf(object)
	if objValue.IsZero() {
		return true
	}
	switch objValue.Kind() {
	case reflect.Chan, reflect.Map, reflect.Slice:
		return objValue.Len() == 0
	case reflect.Ptr:
		return isEmpty(objValue.Elem().Interface())
	}
	return false
}

// getLen tries to get the length of an object.
func getLen(x any) (int, bool) {
	v := reflect.ValueOf(x)
	defer func() {
		recover()
	}()
	return v.Len(), true
}

// containsElement checks if a container contains an element.
func containsElement(container, element any) (ok, found bool) {
	containerValue := reflect.ValueOf(container)
	containerType := reflect.TypeOf(container)
	if containerType == nil {
		return false, false
	}
	containerKind := containerType.Kind()
	defer func() {
		if e := recover(); e != nil {
			ok = false
			found = false
		}
	}()
	if containerKind == reflect.String {
		elementValue := reflect.ValueOf(element)
		return true, strings.Contains(containerValue.String(), elementValue.String())
	}
	if containerKind == reflect.Map {
		mapKeys := containerValue.MapKeys()
		for i := 0; i < len(mapKeys); i++ {
			if objectsAreEqual(mapKeys[i].Interface(), element) {
				return true, true
			}
		}
		return true, false
	}
	for i := 0; i < containerValue.Len(); i++ {
		if objectsAreEqual(containerValue.Index(i).Interface(), element) {
			return true, true
		}
	}
	return true, false
}

// isList checks if the provided value is an array or slice.
func isList(list any) bool {
	kind := reflect.TypeOf(list).Kind()
	return kind == reflect.Array || kind == reflect.Slice
}

// diffLists returns elements that are only in A and only in B.
func diffLists(listA, listB any) (extraA, extraB []any) {
	aValue := reflect.ValueOf(listA)
	bValue := reflect.ValueOf(listB)
	aLen := aValue.Len()
	bLen := bValue.Len()
	visited := make([]bool, bLen)
	for i := 0; i < aLen; i++ {
		element := aValue.Index(i).Interface()
		found := false
		for j := 0; j < bLen; j++ {
			if visited[j] {
				continue
			}
			if objectsAreEqual(bValue.Index(j).Interface(), element) {
				visited[j] = true
				found = true
				break
			}
		}
		if !found {
			extraA = append(extraA, element)
		}
	}
	for j := 0; j < bLen; j++ {
		if !visited[j] {
			extraB = append(extraB, bValue.Index(j).Interface())
		}
	}
	return
}

// formatListDiff formats the difference between two lists.
func formatListDiff(listA, listB any, extraA, extraB []any) string {
	var msg bytes.Buffer
	msg.WriteString("elements differ")
	if len(extraA) > 0 {
		if colorEnabled {
			msg.WriteString("\n\n" + color.Red.Apply("extra elements in list A:") + "\n")
			msg.WriteString(color.Red.Apply(fmt.Sprintf("%#v", extraA)))
		} else {
			msg.WriteString("\n\nextra elements in list A:\n")
			msg.WriteString(fmt.Sprintf("%#v", extraA))
		}
	}
	if len(extraB) > 0 {
		if colorEnabled {
			msg.WriteString("\n\n" + color.Green.Apply("extra elements in list B:") + "\n")
			msg.WriteString(color.Green.Apply(fmt.Sprintf("%#v", extraB)))
		} else {
			msg.WriteString("\n\nextra elements in list B:\n")
			msg.WriteString(fmt.Sprintf("%#v", extraB))
		}
	}
	msg.WriteString("\n\nlistA:\n")
	msg.WriteString(fmt.Sprintf("%#v", listA))
	msg.WriteString("\n\nlistB:\n")
	msg.WriteString(fmt.Sprintf("%#v", listB))
	return msg.String()
}

// formatUnequalValues formats two values for display when they are not equal.
func formatUnequalValues(expected, actual any) (string, string) {
	var expStr, actStr string
	if reflect.TypeOf(expected) != reflect.TypeOf(actual) {
		expStr = fmt.Sprintf("%T(%#v)", expected, expected)
		actStr = fmt.Sprintf("%T(%#v)", actual, actual)
	} else {
		expStr = fmt.Sprintf("%#v", expected)
		actStr = fmt.Sprintf("%#v", actual)
	}
	if colorEnabled {
		return color.Red.Apply(expStr), color.Green.Apply(actStr)
	}
	return expStr, actStr
}

// formatDiff returns a diff of two values if they are comparable.
func formatDiff(expected, actual any) string {
	if expected == nil || actual == nil {
		return ""
	}
	et, ek := typeAndKind(expected)
	at, _ := typeAndKind(actual)
	if et != at {
		return ""
	}
	if ek != reflect.Struct && ek != reflect.Map && ek != reflect.Slice && ek != reflect.Array && ek != reflect.String {
		return ""
	}
	e := fmt.Sprintf("%#v", expected)
	a := fmt.Sprintf("%#v", actual)
	if e == a {
		return ""
	}
	if colorEnabled {
		return "\n\nDiff:\n" +
			color.Red.Apply("--- expected") + "\n" +
			color.Green.Apply("+++ actual") + "\n" +
			color.Red.Apply("-"+e) + "\n" +
			color.Green.Apply("+"+a)
	}
	return "\n\nDiff:\n--- expected\n+++ actual\n-" + e + "\n+" + a
}

// typeAndKind returns the type and kind of a value, dereferencing pointers.
func typeAndKind(v any) (reflect.Type, reflect.Kind) {
	t := reflect.TypeOf(v)
	k := t.Kind()
	if k == reflect.Ptr {
		t = t.Elem()
		k = t.Kind()
	}
	return t, k
}

// checkPanic checks if a function panics and returns the panic value.
func checkPanic(f func()) (didPanic bool, panicValue any) {
	didPanic = true
	defer func() {
		panicValue = recover()
		if panicValue == nil {
			didPanic = false
		}
	}()
	f()
	didPanic = false
	return
}

// matchRegexp returns true if a specified regexp matches a string.
func matchRegexp(rx any, str any) bool {
	var r *regexp.Regexp
	if rr, ok := rx.(*regexp.Regexp); ok {
		r = rr
	} else {
		r = regexp.MustCompile(fmt.Sprint(rx))
	}
	switch v := str.(type) {
	case []byte:
		return r.Match(v)
	case string:
		return r.MatchString(v)
	default:
		return r.MatchString(fmt.Sprint(v))
	}
}
