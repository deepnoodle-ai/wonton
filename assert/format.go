package assert

import (
	"bytes"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/deepnoodle-ai/wonton/color"
)

// colorEnabled controls whether colored output is used.
// It defaults to true if stderr is a terminal.
var colorEnabled = color.IsTerminal(os.Stderr)

// SetColorEnabled enables or disables colored output.
func SetColorEnabled(enabled bool) {
	colorEnabled = enabled
}

// ColorEnabled returns whether colored output is enabled.
func ColorEnabled() bool {
	return colorEnabled
}

// formatMessage formats the optional message and arguments.
func formatMessage(msgAndArgs ...any) string {
	if len(msgAndArgs) == 0 {
		return ""
	}
	if len(msgAndArgs) == 1 {
		if msg, ok := msgAndArgs[0].(string); ok {
			return msg
		}
		return fmt.Sprintf("%+v", msgAndArgs[0])
	}
	if msg, ok := msgAndArgs[0].(string); ok {
		return fmt.Sprintf(msg, msgAndArgs[1:]...)
	}
	return ""
}

// labeledContent represents a labeled piece of output.
type labeledContent struct {
	label   string
	content string
}

// formatLabeledOutput formats labeled content for display.
func formatLabeledOutput(content ...labeledContent) string {
	longestLabel := 0
	for _, v := range content {
		if len(v.label) > longestLabel {
			longestLabel = len(v.label)
		}
	}
	var output string
	for _, v := range content {
		label := v.label
		if colorEnabled {
			label = color.Cyan.Apply(v.label)
		}
		output += "\t" + label + ":" + strings.Repeat(" ", longestLabel-len(v.label)) + "\t" + indentMessageLines(v.content, longestLabel) + "\n"
	}
	return output
}

// indentMessageLines aligns multi-line messages.
func indentMessageLines(message string, longestLabelLen int) string {
	lines := strings.Split(message, "\n")
	if len(lines) == 1 {
		return message
	}
	indent := "\n\t" + strings.Repeat(" ", longestLabelLen+1) + "\t"
	return strings.Join(lines, indent)
}

// callerInfo returns an array of strings containing the file and line number
// of each stack frame leading to the assert call.
func callerInfo() []string {
	const maxFrames = 10
	pcs := make([]uintptr, maxFrames)

	callers := []string{}
	offset := 1

	for {
		n := runtime.Callers(offset, pcs)
		if n == 0 {
			break
		}
		frames := runtime.CallersFrames(pcs[:n])
		for {
			frame, more := frames.Next()
			file := frame.File
			line := frame.Line
			if file == "<autogenerated>" {
				break
			}
			f := runtime.FuncForPC(frame.PC)
			if f == nil {
				break
			}
			name := f.Name()
			if name == "testing.tRunner" {
				break
			}
			parts := strings.Split(file, "/")
			if len(parts) > 1 {
				dir := parts[len(parts)-2]
				if dir != "assert" && dir != "require" {
					callers = append(callers, fmt.Sprintf("%s:%d", file, line))
				}
			}
			// Drop the package
			dotPos := strings.LastIndexByte(name, '.')
			name = name[dotPos+1:]
			if isTest(name, "Test") || isTest(name, "Benchmark") || isTest(name, "Example") {
				break
			}
			if !more {
				break
			}
		}
		offset += cap(pcs)
	}
	return callers
}

// isTest tells whether name looks like a test function.
func isTest(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) {
		return true
	}
	r, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(r)
}

// formatListDiff formats the difference between two lists.
func formatListDiff(listA, listB any, extraA, extraB []any) string {
	var msg bytes.Buffer
	msg.WriteString("elements differ")
	if len(extraA) > 0 {
		if colorEnabled {
			msg.WriteString("\n\n" + color.Red.Apply("extra elements in list A:") + "\n")
			msg.WriteString(color.Red.Apply(fmt.Sprintf("%#v", extraA)))
		} else {
			msg.WriteString("\n\nextra elements in list A:\n")
			msg.WriteString(fmt.Sprintf("%#v", extraA))
		}
	}
	if len(extraB) > 0 {
		if colorEnabled {
			msg.WriteString("\n\n" + color.Green.Apply("extra elements in list B:") + "\n")
			msg.WriteString(color.Green.Apply(fmt.Sprintf("%#v", extraB)))
		} else {
			msg.WriteString("\n\nextra elements in list B:\n")
			msg.WriteString(fmt.Sprintf("%#v", extraB))
		}
	}
	msg.WriteString("\n\nlistA:\n")
	msg.WriteString(fmt.Sprintf("%#v", listA))
	msg.WriteString("\n\nlistB:\n")
	msg.WriteString(fmt.Sprintf("%#v", listB))
	return msg.String()
}

// formatUnequalValues formats two values for display when they are not equal.
func formatUnequalValues(expected, actual any) (string, string) {
	var expStr, actStr string
	if reflect.TypeOf(expected) != reflect.TypeOf(actual) {
		expStr = fmt.Sprintf("%T(%#v)", expected, expected)
		actStr = fmt.Sprintf("%T(%#v)", actual, actual)
	} else {
		expStr = fmt.Sprintf("%#v", expected)
		actStr = fmt.Sprintf("%#v", actual)
	}
	if colorEnabled {
		return color.Red.Apply(expStr), color.Green.Apply(actStr)
	}
	return expStr, actStr
}

// formatDiff returns a diff of two values if they are comparable.
func formatDiff(expected, actual any) string {
	if expected == nil || actual == nil {
		return ""
	}
	et, ek := typeAndKind(expected)
	at, _ := typeAndKind(actual)
	if et != at {
		return ""
	}
	if ek != reflect.Struct && ek != reflect.Map && ek != reflect.Slice && ek != reflect.Array && ek != reflect.String {
		return ""
	}
	e := fmt.Sprintf("%#v", expected)
	a := fmt.Sprintf("%#v", actual)
	if e == a {
		return ""
	}
	if colorEnabled {
		return "\n\nDiff:\n" +
			color.Red.Apply("--- expected") + "\n" +
			color.Green.Apply("+++ actual") + "\n" +
			color.Red.Apply("-"+e) + "\n" +
			color.Green.Apply("+"+a)
	}
	return "\n\nDiff:\n--- expected\n+++ actual\n-" + e + "\n+" + a
}
